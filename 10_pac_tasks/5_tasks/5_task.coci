#include <stdio.h>
#include <stdlib.h>

int main(void) {
    const long long MOD = 1000000007LL;

    // Читаем все целые числа из stdin как массив strength[]
    int cap = 1024;
    int n = 0;
    int *a = (int*)malloc(cap * sizeof(int));
    if (!a) return 0;

    int x;
    while (scanf("%d", &x) == 1) {
        if (n == cap) {
            cap *= 2;
            int *na = (int*)realloc(a, cap * sizeof(int));
            if (!na) { free(a); return 0; }
            a = na;
        }
        a[n++] = x;
    }
    if (n == 0) {
        printf("0\n");
        free(a);
        return 0;
    }

    // Массивы для предыдущего строго меньшего (L) и следующего меньшего или равного (R)
    int *L = (int*)malloc(n * sizeof(int));
    int *R = (int*)malloc(n * sizeof(int));
    int *st = (int*)malloc(n * sizeof(int));
    if (!L || !R || !st) { free(a); free(L); free(R); free(st); return 0; }

    // prev less: L[i] — индекс предыдущего строго меньшего элемента, либо -1
    int top = 0;
    for (int i = 0; i < n; ++i) {
        while (top > 0 && a[st[top - 1]] >= a[i]) {
            --top;
        }
        L[i] = (top > 0 ? st[top - 1] : -1);
        st[top++] = i;
    }

    // next less or equal: R[i] — индекс следующего меньшего или равного элемента, либо n
    top = 0;
    for (int i = n - 1; i >= 0; --i) {
        while (top > 0 && a[st[top - 1]] > a[i]) {
            --top;
        }
        R[i] = (top > 0 ? st[top - 1] : n);
        st[top++] = i;
    }

    // Префиксные суммы P: P[k] = sum_{t=0..k-1} a[t], размер n+1
    long long *P = (long long*)malloc((n + 1) * sizeof(long long));
    // Двойные префиксные суммы PP: PP[k] = sum_{t=0..k-1} P[t], размер n+2
    long long *PP = (long long*)malloc((n + 2) * sizeof(long long));
    if (!P || !PP) {
        free(a); free(L); free(R); free(st); free(P); free(PP);
        return 0;
    }

    P[0] = 0;
    for (int i = 0; i < n; ++i) {
        P[i + 1] = (P[i] + (long long)a[i]) % MOD;
    }
    PP[0] = 0;
    for (int i = 0; i <= n; ++i) {
        PP[i + 1] = (PP[i] + P[i]) % MOD; // обратите внимание: используем P[i], а не P[i+1]
    }

    // Суммируем вклад каждого i как минимума по формуле:
    // S_i = (i-L)*(PP[R+1]-PP[i+1]) - (R-i)*(PP[i+1]-PP[L+1])
    // contribution = a[i] * S_i
    long long ans = 0;
    for (int i = 0; i < n; ++i) {
        int l = L[i];
        int r = R[i];
        long long left = (long long)(i - l);
        long long right = (long long)(r - i);

        long long part1 = (PP[r + 1] - PP[i + 1]) % MOD;
        if (part1 < 0) part1 += MOD;

        long long part2 = (PP[i + 1] - PP[l + 1]) % MOD;
        if (part2 < 0) part2 += MOD;

        long long S = (left % MOD) * part1 % MOD;
        long long T = (right % MOD) * part2 % MOD;

        long long contrib = ((S - T) % MOD + MOD) % MOD;
        contrib = (contrib * (a[i] % MOD)) % MOD;

        ans = (ans + contrib) % MOD;
    }

    printf("%lld\n", ans);

    free(a);
    free(L);
    free(R);
    free(st);
    free(P);
    free(PP);
    return 0;
}
