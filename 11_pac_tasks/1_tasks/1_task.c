#include <stdio.h>
#include <stdlib.h>


// ---------- ХЕШ-ФУНКЦИЯ ----------
// Преобразует целое число в индекс хеш-таблицы.
// Умножение на константу используется для равномерного распределения значений.
// Взятие по модулю ограничивает индекс диапазоном 0..1000002.
unsigned hsh(unsigned x)
{
    return (x * 1293921838u) % 1000003;
}

int main(void)
{
    // ---------- ОТКРЫТИЕ ВХОДНОГО И ВЫХОДНОГО ФАЙЛОВ (БИНАРНЫЙ ФОРМАТ) ----------
    FILE *input = fopen("input.txt", "rb");
    FILE *output = fopen("output.txt", "wb");

    // ---------- ЧТЕНИЕ КОЛИЧЕСТВА ЧИСЕЛ ----------
    int n;
    fread(&n, sizeof(int), 1, input);

    // ---------- ЧТЕНИЕ ВХОДНОГО МАССИВА ----------
    int *vals = malloc(n * sizeof(int));
    fread(vals, sizeof(int), n, input);

    // ---------- СОЗДАНИЕ ХЕШ-ТАБЛИЦЫ ----------
    // tab  — хранит значения
    // used — показывает, занята ли ячейка
    int *tab = malloc(1000003 * sizeof(int));
    unsigned char *used = calloc(1000003, 1);

    // ---------- МАССИВ ДЛЯ РЕЗУЛЬТАТА ----------
    // В него записываются только первые вхождения значений.
    int *out = malloc(n * sizeof(int));
    int outc = 0;

    // ---------- ОСНОВНОЙ ЦИКЛ УДАЛЕНИЯ ДУБЛИКАТОВ ----------
    // Проходим по массиву слева направо.
    // Если значение встречается впервые — добавляем его в хеш-таблицу и в результат.
    for (int i = 0; i < n; i++)
    {
        int v = vals[i];

        unsigned p = hsh((unsigned)v);

        // Разрешение коллизий методом линейного пробирования
        while (used[p] && tab[p] != v)
        {
            p = (p + 1) % 1000003;
        }

        // Если ячейка была пустой, значит это первое вхождение
        if (!used[p])
        {
            used[p] = 1;
            tab[p] = v;

            out[outc] = v;
            outc = outc + 1;
        }
    }

    // ---------- ЗАПИСЬ РЕЗУЛЬТАТА В ВЫХОДНОЙ ФАЙЛ ----------
    // Сначала количество уникальных значений,
    // затем сами значения в порядке первых вхождений.
    fwrite(&outc, sizeof(int), 1, output);
    fwrite(out, sizeof(int), outc, output);

    // ---------- ОСВОБОЖДЕНИЕ ПАМЯТИ И ЗАКРЫТИЕ ФАЙЛОВ ----------
    free(vals);
    free(tab);
    free(used);
    free(out);

    fclose(output);
    fclose(input);

    return 0;
}