#include <stdio.h>


// pref — строка, в которую дописываем
// suff — строка, которую дописываем

//  1. Находим конец строки pref (символ '\0').
//  2. Посимвольно копируем символы из suff в найденную позицию.
//  3. После копирования вставляем завершающий '\0'.

// Возвращаем указатель на конец склеенной строки
char *concat(char *pref, char *suff) 
{
    // 1. Идём по pref, пока не найдём её конец ('\0')
    while (*pref != '\0') 
    {
        pref++; // сдвигаемся вправо
    }

    // Теперь pref указывает на финальный '\0' первой строки

    // 2. Копируем символы suff в конец pref
    while (*suff != '\0') 
    {
        *pref = *suff; // копируем текущий символ
        pref++;        // сдвигаем позицию для записи
        suff++;        // сдвигаем позицию чтения
    }

    // 3. По завершении копирования ставим конец строки
    *pref = '\0';

    // 4. Возвращаем указатель на конец строки (на '\0')
    return pref;
}

int main() 
{
    // Открываем входной и выходной файлы
    FILE *input = fopen("input.txt", "r");
    FILE *output = fopen("output.txt", "w");

    int N;
    fscanf(input, "%d", &N);  // Считываем количество строк

    // Итоговый буфер для всех строк сразу:
    // максимум 10 000 строк * 100 символов = 1 000 000 символов.
    // В нашем случае создаём буфер размером N * 101
    // (100 символов + '\0') — этого достаточно.
    char result[N * 101];
    result[0] = '\0'; // Ставим пустую строку, иначе concat не найдёт начало

    char buffer[101]; // Буфер для одной входной строки

    // Читаем N строк и склеиваем их в общую строку result
    for (int i = 0; i < N; i++) 
    {
        fscanf(input, "%s", buffer); // Считываем очередную строку
        concat(result, buffer);      // Дописываем её в конец result
    }

    // Выводим итоговую склеенную строку
    fprintf(output, "%s", result);

    fclose(input);
    fclose(output);
    return 0;
}